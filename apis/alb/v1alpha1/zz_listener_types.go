/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ACLConfigObservation struct {
}

type ACLConfigParameters struct {

	// +kubebuilder:validation:Optional
	ACLRelations []ACLRelationsParameters `json:"aclRelations,omitempty" tf:"acl_relations,omitempty"`

	// +kubebuilder:validation:Optional
	ACLType *string `json:"aclType,omitempty" tf:"acl_type,omitempty"`
}

type ACLRelationsObservation struct {
	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type ACLRelationsParameters struct {

	// +kubebuilder:validation:Optional
	ACLID *string `json:"aclId,omitempty" tf:"acl_id,omitempty"`
}

type AccessLogTracingConfigObservation struct {
}

type AccessLogTracingConfigParameters struct {

	// +kubebuilder:validation:Optional
	TracingEnabled *bool `json:"tracingEnabled,omitempty" tf:"tracing_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	TracingSample *float64 `json:"tracingSample,omitempty" tf:"tracing_sample,omitempty"`

	// +kubebuilder:validation:Optional
	TracingType *string `json:"tracingType,omitempty" tf:"tracing_type,omitempty"`
}

type CertificatesObservation struct {
}

type CertificatesParameters struct {

	// +kubebuilder:validation:Optional
	CertificateID *string `json:"certificateId,omitempty" tf:"certificate_id,omitempty"`
}

type DefaultActionsObservation struct {
}

type DefaultActionsParameters struct {

	// +kubebuilder:validation:Required
	ForwardGroupConfig []ForwardGroupConfigParameters `json:"forwardGroupConfig" tf:"forward_group_config,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type ForwardGroupConfigObservation struct {
}

type ForwardGroupConfigParameters struct {

	// +kubebuilder:validation:Required
	ServerGroupTuples []ServerGroupTuplesParameters `json:"serverGroupTuples" tf:"server_group_tuples,omitempty"`
}

type ListenerObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ListenerParameters struct {

	// +kubebuilder:validation:Optional
	ACLConfig []ACLConfigParameters `json:"aclConfig,omitempty" tf:"acl_config,omitempty"`

	// +kubebuilder:validation:Optional
	AccessLogRecordCustomizedHeadersEnabled *bool `json:"accessLogRecordCustomizedHeadersEnabled,omitempty" tf:"access_log_record_customized_headers_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	AccessLogTracingConfig []AccessLogTracingConfigParameters `json:"accessLogTracingConfig,omitempty" tf:"access_log_tracing_config,omitempty"`

	// +kubebuilder:validation:Optional
	Certificates []CertificatesParameters `json:"certificates,omitempty" tf:"certificates,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultActions []DefaultActionsParameters `json:"defaultActions,omitempty" tf:"default_actions,omitempty"`

	// +kubebuilder:validation:Optional
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// +kubebuilder:validation:Optional
	GzipEnabled *bool `json:"gzipEnabled,omitempty" tf:"gzip_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Http2Enabled *bool `json:"http2Enabled,omitempty" tf:"http2_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	IdleTimeout *float64 `json:"idleTimeout,omitempty" tf:"idle_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	ListenerDescription *string `json:"listenerDescription,omitempty" tf:"listener_description,omitempty"`

	// +kubebuilder:validation:Required
	ListenerPort *float64 `json:"listenerPort" tf:"listener_port,omitempty"`

	// +kubebuilder:validation:Required
	ListenerProtocol *string `json:"listenerProtocol" tf:"listener_protocol,omitempty"`

	// +kubebuilder:validation:Required
	LoadBalancerID *string `json:"loadBalancerId" tf:"load_balancer_id,omitempty"`

	// +kubebuilder:validation:Optional
	QuicConfig []QuicConfigParameters `json:"quicConfig,omitempty" tf:"quic_config,omitempty"`

	// +kubebuilder:validation:Optional
	RequestTimeout *float64 `json:"requestTimeout,omitempty" tf:"request_timeout,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityPolicyID *string `json:"securityPolicyId,omitempty" tf:"security_policy_id,omitempty"`

	// +kubebuilder:validation:Optional
	Status *string `json:"status,omitempty" tf:"status,omitempty"`

	// +kubebuilder:validation:Optional
	XforwardedForConfig []XforwardedForConfigParameters `json:"xforwardedForConfig,omitempty" tf:"xforwarded_for_config,omitempty"`
}

type QuicConfigObservation struct {
}

type QuicConfigParameters struct {

	// +kubebuilder:validation:Optional
	QuicListenerID *string `json:"quicListenerId,omitempty" tf:"quic_listener_id,omitempty"`

	// +kubebuilder:validation:Optional
	QuicUpgradeEnabled *bool `json:"quicUpgradeEnabled,omitempty" tf:"quic_upgrade_enabled,omitempty"`
}

type ServerGroupTuplesObservation struct {
}

type ServerGroupTuplesParameters struct {

	// +kubebuilder:validation:Required
	ServerGroupID *string `json:"serverGroupId" tf:"server_group_id,omitempty"`
}

type XforwardedForConfigObservation struct {
}

type XforwardedForConfigParameters struct {

	// +kubebuilder:validation:Optional
	XforwardedforclientcertIssuerdnalias *string `json:"xforwardedforclientcertIssuerdnalias,omitempty" tf:"xforwardedforclientcert_issuerdnalias,omitempty"`

	// +kubebuilder:validation:Optional
	XforwardedforclientcertIssuerdnenabled *bool `json:"xforwardedforclientcertIssuerdnenabled,omitempty" tf:"xforwardedforclientcert_issuerdnenabled,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforclientcertclientverifyalias *string `json:"xforwardedforclientcertclientverifyalias,omitempty" tf:"xforwardedforclientcertclientverifyalias,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforclientcertclientverifyenabled *bool `json:"xforwardedforclientcertclientverifyenabled,omitempty" tf:"xforwardedforclientcertclientverifyenabled,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforclientcertfingerprintalias *string `json:"xforwardedforclientcertfingerprintalias,omitempty" tf:"xforwardedforclientcertfingerprintalias,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforclientcertfingerprintenabled *bool `json:"xforwardedforclientcertfingerprintenabled,omitempty" tf:"xforwardedforclientcertfingerprintenabled,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforclientcertsubjectdnalias *string `json:"xforwardedforclientcertsubjectdnalias,omitempty" tf:"xforwardedforclientcertsubjectdnalias,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforclientcertsubjectdnenabled *bool `json:"xforwardedforclientcertsubjectdnenabled,omitempty" tf:"xforwardedforclientcertsubjectdnenabled,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforclientsrcportenabled *bool `json:"xforwardedforclientsrcportenabled,omitempty" tf:"xforwardedforclientsrcportenabled,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforenabled *bool `json:"xforwardedforenabled,omitempty" tf:"xforwardedforenabled,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforprotoenabled *bool `json:"xforwardedforprotoenabled,omitempty" tf:"xforwardedforprotoenabled,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforslbidenabled *bool `json:"xforwardedforslbidenabled,omitempty" tf:"xforwardedforslbidenabled,omitempty"`

	// +kubebuilder:validation:Optional
	Xforwardedforslbportenabled *bool `json:"xforwardedforslbportenabled,omitempty" tf:"xforwardedforslbportenabled,omitempty"`
}

// ListenerSpec defines the desired state of Listener
type ListenerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ListenerParameters `json:"forProvider"`
}

// ListenerStatus defines the observed state of Listener.
type ListenerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ListenerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Listener is the Schema for the Listeners API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type Listener struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ListenerSpec   `json:"spec"`
	Status            ListenerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ListenerList contains a list of Listeners
type ListenerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Listener `json:"items"`
}

// Repository type metadata.
var (
	Listener_Kind             = "Listener"
	Listener_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Listener_Kind}.String()
	Listener_KindAPIVersion   = Listener_Kind + "." + CRDGroupVersion.String()
	Listener_GroupVersionKind = CRDGroupVersion.WithKind(Listener_Kind)
)

func init() {
	SchemeBuilder.Register(&Listener{}, &ListenerList{})
}
