/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CookieConfigObservation struct {
}

type CookieConfigParameters struct {

	// +kubebuilder:validation:Optional
	Values []ValuesParameters `json:"values,omitempty" tf:"values,omitempty"`
}

type FixedResponseConfigObservation struct {
}

type FixedResponseConfigParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Optional
	ContentType *string `json:"contentType,omitempty" tf:"content_type,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPCode *string `json:"httpCode,omitempty" tf:"http_code,omitempty"`
}

type ForwardGroupConfigServerGroupTuplesObservation struct {
}

type ForwardGroupConfigServerGroupTuplesParameters struct {

	// +kubebuilder:validation:Optional
	ServerGroupID *string `json:"serverGroupId,omitempty" tf:"server_group_id,omitempty"`
}

type HeaderConfigObservation struct {
}

type HeaderConfigParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type HostConfigObservation struct {
}

type HostConfigParameters struct {

	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type InsertHeaderConfigObservation struct {
}

type InsertHeaderConfigParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`

	// +kubebuilder:validation:Optional
	ValueType *string `json:"valueType,omitempty" tf:"value_type,omitempty"`
}

type MethodConfigObservation struct {
}

type MethodConfigParameters struct {

	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type PathConfigObservation struct {
}

type PathConfigParameters struct {

	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type QueryStringConfigObservation struct {
}

type QueryStringConfigParameters struct {

	// +kubebuilder:validation:Optional
	Values []QueryStringConfigValuesParameters `json:"values,omitempty" tf:"values,omitempty"`
}

type QueryStringConfigValuesObservation struct {
}

type QueryStringConfigValuesParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type RedirectConfigObservation struct {
}

type RedirectConfigParameters struct {

	// +kubebuilder:validation:Optional
	HTTPCode *string `json:"httpCode,omitempty" tf:"http_code,omitempty"`

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Optional
	Query *string `json:"query,omitempty" tf:"query,omitempty"`
}

type RewriteConfigObservation struct {
}

type RewriteConfigParameters struct {

	// +kubebuilder:validation:Optional
	Host *string `json:"host,omitempty" tf:"host,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`

	// +kubebuilder:validation:Optional
	Query *string `json:"query,omitempty" tf:"query,omitempty"`
}

type RuleActionsForwardGroupConfigObservation struct {
}

type RuleActionsForwardGroupConfigParameters struct {

	// +kubebuilder:validation:Optional
	ServerGroupTuples []ForwardGroupConfigServerGroupTuplesParameters `json:"serverGroupTuples,omitempty" tf:"server_group_tuples,omitempty"`
}

type RuleActionsObservation struct {
}

type RuleActionsParameters struct {

	// +kubebuilder:validation:Optional
	FixedResponseConfig []FixedResponseConfigParameters `json:"fixedResponseConfig,omitempty" tf:"fixed_response_config,omitempty"`

	// +kubebuilder:validation:Optional
	ForwardGroupConfig []RuleActionsForwardGroupConfigParameters `json:"forwardGroupConfig,omitempty" tf:"forward_group_config,omitempty"`

	// +kubebuilder:validation:Optional
	InsertHeaderConfig []InsertHeaderConfigParameters `json:"insertHeaderConfig,omitempty" tf:"insert_header_config,omitempty"`

	// +kubebuilder:validation:Required
	Order *float64 `json:"order" tf:"order,omitempty"`

	// +kubebuilder:validation:Optional
	RedirectConfig []RedirectConfigParameters `json:"redirectConfig,omitempty" tf:"redirect_config,omitempty"`

	// +kubebuilder:validation:Optional
	RewriteConfig []RewriteConfigParameters `json:"rewriteConfig,omitempty" tf:"rewrite_config,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type RuleConditionsObservation struct {
}

type RuleConditionsParameters struct {

	// +kubebuilder:validation:Optional
	CookieConfig []CookieConfigParameters `json:"cookieConfig,omitempty" tf:"cookie_config,omitempty"`

	// +kubebuilder:validation:Optional
	HeaderConfig []HeaderConfigParameters `json:"headerConfig,omitempty" tf:"header_config,omitempty"`

	// +kubebuilder:validation:Optional
	HostConfig []HostConfigParameters `json:"hostConfig,omitempty" tf:"host_config,omitempty"`

	// +kubebuilder:validation:Optional
	MethodConfig []MethodConfigParameters `json:"methodConfig,omitempty" tf:"method_config,omitempty"`

	// +kubebuilder:validation:Optional
	PathConfig []PathConfigParameters `json:"pathConfig,omitempty" tf:"path_config,omitempty"`

	// +kubebuilder:validation:Optional
	QueryStringConfig []QueryStringConfigParameters `json:"queryStringConfig,omitempty" tf:"query_string_config,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type RuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type RuleParameters struct {

	// +kubebuilder:validation:Optional
	DryRun *bool `json:"dryRun,omitempty" tf:"dry_run,omitempty"`

	// +kubebuilder:validation:Required
	ListenerID *string `json:"listenerId" tf:"listener_id,omitempty"`

	// +kubebuilder:validation:Required
	Priority *float64 `json:"priority" tf:"priority,omitempty"`

	// +kubebuilder:validation:Required
	RuleActions []RuleActionsParameters `json:"ruleActions" tf:"rule_actions,omitempty"`

	// +kubebuilder:validation:Required
	RuleConditions []RuleConditionsParameters `json:"ruleConditions" tf:"rule_conditions,omitempty"`

	// +kubebuilder:validation:Required
	RuleName *string `json:"ruleName" tf:"rule_name,omitempty"`
}

type ValuesObservation struct {
}

type ValuesParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

// RuleSpec defines the desired state of Rule
type RuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     RuleParameters `json:"forProvider"`
}

// RuleStatus defines the observed state of Rule.
type RuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        RuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Rule is the Schema for the Rules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type Rule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RuleSpec   `json:"spec"`
	Status            RuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// RuleList contains a list of Rules
type RuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Rule `json:"items"`
}

// Repository type metadata.
var (
	Rule_Kind             = "Rule"
	Rule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Rule_Kind}.String()
	Rule_KindAPIVersion   = Rule_Kind + "." + CRDGroupVersion.String()
	Rule_GroupVersionKind = CRDGroupVersion.WithKind(Rule_Kind)
)

func init() {
	SchemeBuilder.Register(&Rule{}, &RuleList{})
}
