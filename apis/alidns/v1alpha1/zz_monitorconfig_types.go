/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type IspCityNodeObservation struct {
}

type IspCityNodeParameters struct {

	// +kubebuilder:validation:Required
	CityCode *string `json:"cityCode" tf:"city_code,omitempty"`

	// +kubebuilder:validation:Required
	IspCode *string `json:"ispCode" tf:"isp_code,omitempty"`
}

type MonitorConfigObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type MonitorConfigParameters struct {

	// +kubebuilder:validation:Required
	AddrPoolID *string `json:"addrPoolId" tf:"addr_pool_id,omitempty"`

	// +kubebuilder:validation:Required
	EvaluationCount *float64 `json:"evaluationCount" tf:"evaluation_count,omitempty"`

	// +kubebuilder:validation:Required
	Interval *float64 `json:"interval" tf:"interval,omitempty"`

	// +kubebuilder:validation:Required
	IspCityNode []IspCityNodeParameters `json:"ispCityNode" tf:"isp_city_node,omitempty"`

	// +kubebuilder:validation:Optional
	Lang *string `json:"lang,omitempty" tf:"lang,omitempty"`

	// +kubebuilder:validation:Required
	MonitorExtendInfo *string `json:"monitorExtendInfo" tf:"monitor_extend_info,omitempty"`

	// +kubebuilder:validation:Required
	ProtocolType *string `json:"protocolType" tf:"protocol_type,omitempty"`

	// +kubebuilder:validation:Required
	Timeout *float64 `json:"timeout" tf:"timeout,omitempty"`
}

// MonitorConfigSpec defines the desired state of MonitorConfig
type MonitorConfigSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MonitorConfigParameters `json:"forProvider"`
}

// MonitorConfigStatus defines the observed state of MonitorConfig.
type MonitorConfigStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MonitorConfigObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MonitorConfig is the Schema for the MonitorConfigs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type MonitorConfig struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MonitorConfigSpec   `json:"spec"`
	Status            MonitorConfigStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MonitorConfigList contains a list of MonitorConfigs
type MonitorConfigList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MonitorConfig `json:"items"`
}

// Repository type metadata.
var (
	MonitorConfig_Kind             = "MonitorConfig"
	MonitorConfig_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MonitorConfig_Kind}.String()
	MonitorConfig_KindAPIVersion   = MonitorConfig_Kind + "." + CRDGroupVersion.String()
	MonitorConfig_GroupVersionKind = CRDGroupVersion.WithKind(MonitorConfig_Kind)
)

func init() {
	SchemeBuilder.Register(&MonitorConfig{}, &MonitorConfigList{})
}
