/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DispatchRuleObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type DispatchRuleParameters struct {

	// +kubebuilder:validation:Required
	DispatchRuleName *string `json:"dispatchRuleName" tf:"dispatch_rule_name,omitempty"`

	// +kubebuilder:validation:Optional
	DispatchType *string `json:"dispatchType,omitempty" tf:"dispatch_type,omitempty"`

	// +kubebuilder:validation:Required
	GroupRules []GroupRulesParameters `json:"groupRules" tf:"group_rules,omitempty"`

	// +kubebuilder:validation:Optional
	IsRecover *bool `json:"isRecover,omitempty" tf:"is_recover,omitempty"`

	// +kubebuilder:validation:Required
	LabelMatchExpressionGrid []LabelMatchExpressionGridParameters `json:"labelMatchExpressionGrid" tf:"label_match_expression_grid,omitempty"`

	// +kubebuilder:validation:Required
	NotifyRules []NotifyRulesParameters `json:"notifyRules" tf:"notify_rules,omitempty"`
}

type GroupRulesObservation struct {
	GroupID *float64 `json:"groupId,omitempty" tf:"group_id,omitempty"`
}

type GroupRulesParameters struct {

	// +kubebuilder:validation:Required
	GroupInterval *float64 `json:"groupInterval" tf:"group_interval,omitempty"`

	// +kubebuilder:validation:Required
	GroupWaitTime *float64 `json:"groupWaitTime" tf:"group_wait_time,omitempty"`

	// +kubebuilder:validation:Required
	GroupingFields []*string `json:"groupingFields" tf:"grouping_fields,omitempty"`

	// +kubebuilder:validation:Optional
	RepeatInterval *float64 `json:"repeatInterval,omitempty" tf:"repeat_interval,omitempty"`
}

type LabelMatchExpressionGridObservation struct {
}

type LabelMatchExpressionGridParameters struct {

	// +kubebuilder:validation:Required
	LabelMatchExpressionGroups []LabelMatchExpressionGroupsParameters `json:"labelMatchExpressionGroups" tf:"label_match_expression_groups,omitempty"`
}

type LabelMatchExpressionGroupsObservation struct {
}

type LabelMatchExpressionGroupsParameters struct {

	// +kubebuilder:validation:Required
	LabelMatchExpressions []LabelMatchExpressionsParameters `json:"labelMatchExpressions" tf:"label_match_expressions,omitempty"`
}

type LabelMatchExpressionsObservation struct {
}

type LabelMatchExpressionsParameters struct {

	// +kubebuilder:validation:Required
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Required
	Operator *string `json:"operator" tf:"operator,omitempty"`

	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type NotifyObjectsObservation struct {
}

type NotifyObjectsParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	NotifyObjectID *string `json:"notifyObjectId" tf:"notify_object_id,omitempty"`

	// +kubebuilder:validation:Required
	NotifyType *string `json:"notifyType" tf:"notify_type,omitempty"`
}

type NotifyRulesObservation struct {
}

type NotifyRulesParameters struct {

	// +kubebuilder:validation:Required
	NotifyChannels []*string `json:"notifyChannels" tf:"notify_channels,omitempty"`

	// +kubebuilder:validation:Required
	NotifyObjects []NotifyObjectsParameters `json:"notifyObjects" tf:"notify_objects,omitempty"`
}

// DispatchRuleSpec defines the desired state of DispatchRule
type DispatchRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DispatchRuleParameters `json:"forProvider"`
}

// DispatchRuleStatus defines the observed state of DispatchRule.
type DispatchRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DispatchRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DispatchRule is the Schema for the DispatchRules API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type DispatchRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DispatchRuleSpec   `json:"spec"`
	Status            DispatchRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DispatchRuleList contains a list of DispatchRules
type DispatchRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DispatchRule `json:"items"`
}

// Repository type metadata.
var (
	DispatchRule_Kind             = "DispatchRule"
	DispatchRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DispatchRule_Kind}.String()
	DispatchRule_KindAPIVersion   = DispatchRule_Kind + "." + CRDGroupVersion.String()
	DispatchRule_GroupVersionKind = CRDGroupVersion.WithKind(DispatchRule_Kind)
)

func init() {
	SchemeBuilder.Register(&DispatchRule{}, &DispatchRuleList{})
}
