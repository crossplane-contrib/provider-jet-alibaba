/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type LaunchTemplateConfigObservation struct {
}

type LaunchTemplateConfigParameters struct {

	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// +kubebuilder:validation:Required
	MaxPrice *string `json:"maxPrice" tf:"max_price,omitempty"`

	// +kubebuilder:validation:Optional
	Priority *string `json:"priority,omitempty" tf:"priority,omitempty"`

	// +kubebuilder:validation:Required
	VswitchID *string `json:"vswitchId" tf:"vswitch_id,omitempty"`

	// +kubebuilder:validation:Required
	WeightedCapacity *string `json:"weightedCapacity" tf:"weighted_capacity,omitempty"`
}

type ProvisioningGroupObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ProvisioningGroupParameters struct {

	// +kubebuilder:validation:Optional
	AutoProvisioningGroupName *string `json:"autoProvisioningGroupName,omitempty" tf:"auto_provisioning_group_name,omitempty"`

	// +kubebuilder:validation:Optional
	AutoProvisioningGroupType *string `json:"autoProvisioningGroupType,omitempty" tf:"auto_provisioning_group_type,omitempty"`

	// +kubebuilder:validation:Optional
	DefaultTargetCapacityType *string `json:"defaultTargetCapacityType,omitempty" tf:"default_target_capacity_type,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	ExcessCapacityTerminationPolicy *string `json:"excessCapacityTerminationPolicy,omitempty" tf:"excess_capacity_termination_policy,omitempty"`

	// +kubebuilder:validation:Required
	LaunchTemplateConfig []LaunchTemplateConfigParameters `json:"launchTemplateConfig" tf:"launch_template_config,omitempty"`

	// +kubebuilder:validation:Required
	LaunchTemplateID *string `json:"launchTemplateId" tf:"launch_template_id,omitempty"`

	// +kubebuilder:validation:Optional
	LaunchTemplateVersion *string `json:"launchTemplateVersion,omitempty" tf:"launch_template_version,omitempty"`

	// +kubebuilder:validation:Optional
	MaxSpotPrice *float64 `json:"maxSpotPrice,omitempty" tf:"max_spot_price,omitempty"`

	// +kubebuilder:validation:Optional
	PayAsYouGoAllocationStrategy *string `json:"payAsYouGoAllocationStrategy,omitempty" tf:"pay_as_you_go_allocation_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	PayAsYouGoTargetCapacity *string `json:"payAsYouGoTargetCapacity,omitempty" tf:"pay_as_you_go_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	SpotAllocationStrategy *string `json:"spotAllocationStrategy,omitempty" tf:"spot_allocation_strategy,omitempty"`

	// +kubebuilder:validation:Optional
	SpotInstanceInterruptionBehavior *string `json:"spotInstanceInterruptionBehavior,omitempty" tf:"spot_instance_interruption_behavior,omitempty"`

	// +kubebuilder:validation:Optional
	SpotInstancePoolsToUseCount *float64 `json:"spotInstancePoolsToUseCount,omitempty" tf:"spot_instance_pools_to_use_count,omitempty"`

	// +kubebuilder:validation:Optional
	SpotTargetCapacity *string `json:"spotTargetCapacity,omitempty" tf:"spot_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	TerminateInstances *bool `json:"terminateInstances,omitempty" tf:"terminate_instances,omitempty"`

	// +kubebuilder:validation:Optional
	TerminateInstancesWithExpiration *bool `json:"terminateInstancesWithExpiration,omitempty" tf:"terminate_instances_with_expiration,omitempty"`

	// +kubebuilder:validation:Required
	TotalTargetCapacity *string `json:"totalTargetCapacity" tf:"total_target_capacity,omitempty"`

	// +kubebuilder:validation:Optional
	ValidFrom *string `json:"validFrom,omitempty" tf:"valid_from,omitempty"`

	// +kubebuilder:validation:Optional
	ValidUntil *string `json:"validUntil,omitempty" tf:"valid_until,omitempty"`
}

// ProvisioningGroupSpec defines the desired state of ProvisioningGroup
type ProvisioningGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ProvisioningGroupParameters `json:"forProvider"`
}

// ProvisioningGroupStatus defines the observed state of ProvisioningGroup.
type ProvisioningGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ProvisioningGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ProvisioningGroup is the Schema for the ProvisioningGroups API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type ProvisioningGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProvisioningGroupSpec   `json:"spec"`
	Status            ProvisioningGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ProvisioningGroupList contains a list of ProvisioningGroups
type ProvisioningGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProvisioningGroup `json:"items"`
}

// Repository type metadata.
var (
	ProvisioningGroup_Kind             = "ProvisioningGroup"
	ProvisioningGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ProvisioningGroup_Kind}.String()
	ProvisioningGroup_KindAPIVersion   = ProvisioningGroup_Kind + "." + CRDGroupVersion.String()
	ProvisioningGroup_GroupVersionKind = CRDGroupVersion.WithKind(ProvisioningGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&ProvisioningGroup{}, &ProvisioningGroupList{})
}
