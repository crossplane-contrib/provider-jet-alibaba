/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AuthConfigObservation struct {
}

type AuthConfigParameters struct {

	// +kubebuilder:validation:Optional
	AuthType *string `json:"authType,omitempty" tf:"auth_type,omitempty"`

	// +kubebuilder:validation:Optional
	MasterKey *string `json:"masterKey,omitempty" tf:"master_key,omitempty"`

	// +kubebuilder:validation:Optional
	SlaveKey *string `json:"slaveKey,omitempty" tf:"slave_key,omitempty"`

	// +kubebuilder:validation:Optional
	Timeout *float64 `json:"timeout,omitempty" tf:"timeout,omitempty"`
}

type CacheConfigObservation struct {
	CacheID *string `json:"cacheId,omitempty" tf:"cache_id,omitempty"`
}

type CacheConfigParameters struct {

	// +kubebuilder:validation:Required
	CacheContent *string `json:"cacheContent" tf:"cache_content,omitempty"`

	// +kubebuilder:validation:Required
	CacheType *string `json:"cacheType" tf:"cache_type,omitempty"`

	// +kubebuilder:validation:Required
	TTL *float64 `json:"ttl" tf:"ttl,omitempty"`

	// +kubebuilder:validation:Optional
	Weight *float64 `json:"weight,omitempty" tf:"weight,omitempty"`
}

type CertificateConfigObservation struct {
}

type CertificateConfigParameters struct {

	// +kubebuilder:validation:Optional
	PrivateKeySecretRef *v1.SecretKeySelector `json:"privateKeySecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ServerCertificateSecretRef *v1.SecretKeySelector `json:"serverCertificateSecretRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	ServerCertificateStatus *string `json:"serverCertificateStatus,omitempty" tf:"server_certificate_status,omitempty"`
}

type DomainObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type DomainParameters struct {

	// +kubebuilder:validation:Optional
	AuthConfig []AuthConfigParameters `json:"authConfig,omitempty" tf:"auth_config,omitempty"`

	// +kubebuilder:validation:Optional
	BlockIps []*string `json:"blockIps,omitempty" tf:"block_ips,omitempty"`

	// +kubebuilder:validation:Optional
	CacheConfig []CacheConfigParameters `json:"cacheConfig,omitempty" tf:"cache_config,omitempty"`

	// +kubebuilder:validation:Required
	CdnType *string `json:"cdnType" tf:"cdn_type,omitempty"`

	// +kubebuilder:validation:Optional
	CertificateConfig []CertificateConfigParameters `json:"certificateConfig,omitempty" tf:"certificate_config,omitempty"`

	// +kubebuilder:validation:Required
	DomainName *string `json:"domainName" tf:"domain_name,omitempty"`

	// +kubebuilder:validation:Optional
	HTTPHeaderConfig []HTTPHeaderConfigParameters `json:"httpHeaderConfig,omitempty" tf:"http_header_config,omitempty"`

	// +kubebuilder:validation:Optional
	OptimizeEnable *string `json:"optimizeEnable,omitempty" tf:"optimize_enable,omitempty"`

	// +kubebuilder:validation:Optional
	Page404Config []Page404ConfigParameters `json:"page404Config,omitempty" tf:"page_404_config,omitempty"`

	// +kubebuilder:validation:Optional
	PageCompressEnable *string `json:"pageCompressEnable,omitempty" tf:"page_compress_enable,omitempty"`

	// +kubebuilder:validation:Optional
	ParameterFilterConfig []ParameterFilterConfigParameters `json:"parameterFilterConfig,omitempty" tf:"parameter_filter_config,omitempty"`

	// +kubebuilder:validation:Optional
	RangeEnable *string `json:"rangeEnable,omitempty" tf:"range_enable,omitempty"`

	// +kubebuilder:validation:Optional
	ReferConfig []ReferConfigParameters `json:"referConfig,omitempty" tf:"refer_config,omitempty"`

	// +kubebuilder:validation:Optional
	Scope *string `json:"scope,omitempty" tf:"scope,omitempty"`

	// +kubebuilder:validation:Optional
	SourcePort *float64 `json:"sourcePort,omitempty" tf:"source_port,omitempty"`

	// +kubebuilder:validation:Optional
	SourceType *string `json:"sourceType,omitempty" tf:"source_type,omitempty"`

	// +kubebuilder:validation:Optional
	Sources []*string `json:"sources,omitempty" tf:"sources,omitempty"`

	// +kubebuilder:validation:Optional
	VideoSeekEnable *string `json:"videoSeekEnable,omitempty" tf:"video_seek_enable,omitempty"`
}

type HTTPHeaderConfigObservation struct {
	HeaderID *string `json:"headerId,omitempty" tf:"header_id,omitempty"`
}

type HTTPHeaderConfigParameters struct {

	// +kubebuilder:validation:Required
	HeaderKey *string `json:"headerKey" tf:"header_key,omitempty"`

	// +kubebuilder:validation:Required
	HeaderValue *string `json:"headerValue" tf:"header_value,omitempty"`
}

type Page404ConfigObservation struct {
	ErrorCode *string `json:"errorCode,omitempty" tf:"error_code,omitempty"`
}

type Page404ConfigParameters struct {

	// +kubebuilder:validation:Optional
	CustomPageURL *string `json:"customPageUrl,omitempty" tf:"custom_page_url,omitempty"`

	// +kubebuilder:validation:Optional
	PageType *string `json:"pageType,omitempty" tf:"page_type,omitempty"`
}

type ParameterFilterConfigObservation struct {
}

type ParameterFilterConfigParameters struct {

	// +kubebuilder:validation:Optional
	Enable *string `json:"enable,omitempty" tf:"enable,omitempty"`

	// +kubebuilder:validation:Optional
	HashKeyArgs []*string `json:"hashKeyArgs,omitempty" tf:"hash_key_args,omitempty"`
}

type ReferConfigObservation struct {
}

type ReferConfigParameters struct {

	// +kubebuilder:validation:Optional
	AllowEmpty *string `json:"allowEmpty,omitempty" tf:"allow_empty,omitempty"`

	// +kubebuilder:validation:Required
	ReferList []*string `json:"referList" tf:"refer_list,omitempty"`

	// +kubebuilder:validation:Optional
	ReferType *string `json:"referType,omitempty" tf:"refer_type,omitempty"`
}

// DomainSpec defines the desired state of Domain
type DomainSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DomainParameters `json:"forProvider"`
}

// DomainStatus defines the observed state of Domain.
type DomainStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DomainObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Domain is the Schema for the Domains API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type Domain struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DomainSpec   `json:"spec"`
	Status            DomainStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DomainList contains a list of Domains
type DomainList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Domain `json:"items"`
}

// Repository type metadata.
var (
	Domain_Kind             = "Domain"
	Domain_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Domain_Kind}.String()
	Domain_KindAPIVersion   = Domain_Kind + "." + CRDGroupVersion.String()
	Domain_GroupVersionKind = CRDGroupVersion.WithKind(Domain_Kind)
)

func init() {
	SchemeBuilder.Register(&Domain{}, &DomainList{})
}
