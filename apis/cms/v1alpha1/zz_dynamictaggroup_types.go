/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type DynamicTagGroupObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type DynamicTagGroupParameters struct {

	// +kubebuilder:validation:Required
	ContactGroupList []*string `json:"contactGroupList" tf:"contact_group_list,omitempty"`

	// +kubebuilder:validation:Required
	MatchExpress []MatchExpressParameters `json:"matchExpress" tf:"match_express,omitempty"`

	// +kubebuilder:validation:Optional
	MatchExpressFilterRelation *string `json:"matchExpressFilterRelation,omitempty" tf:"match_express_filter_relation,omitempty"`

	// +kubebuilder:validation:Required
	TagKey *string `json:"tagKey" tf:"tag_key,omitempty"`

	// +kubebuilder:validation:Optional
	TemplateIDList []*string `json:"templateIdList,omitempty" tf:"template_id_list,omitempty"`
}

type MatchExpressObservation struct {
}

type MatchExpressParameters struct {

	// +kubebuilder:validation:Required
	TagValue *string `json:"tagValue" tf:"tag_value,omitempty"`

	// +kubebuilder:validation:Required
	TagValueMatchFunction *string `json:"tagValueMatchFunction" tf:"tag_value_match_function,omitempty"`
}

// DynamicTagGroupSpec defines the desired state of DynamicTagGroup
type DynamicTagGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     DynamicTagGroupParameters `json:"forProvider"`
}

// DynamicTagGroupStatus defines the observed state of DynamicTagGroup.
type DynamicTagGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        DynamicTagGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// DynamicTagGroup is the Schema for the DynamicTagGroups API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type DynamicTagGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DynamicTagGroupSpec   `json:"spec"`
	Status            DynamicTagGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// DynamicTagGroupList contains a list of DynamicTagGroups
type DynamicTagGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []DynamicTagGroup `json:"items"`
}

// Repository type metadata.
var (
	DynamicTagGroup_Kind             = "DynamicTagGroup"
	DynamicTagGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: DynamicTagGroup_Kind}.String()
	DynamicTagGroup_KindAPIVersion   = DynamicTagGroup_Kind + "." + CRDGroupVersion.String()
	DynamicTagGroup_GroupVersionKind = CRDGroupVersion.WithKind(DynamicTagGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&DynamicTagGroup{}, &DynamicTagGroupList{})
}
