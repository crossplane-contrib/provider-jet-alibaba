/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ServerlessKubernetesAddonsObservation struct {
}

type ServerlessKubernetesAddonsParameters struct {

	// +kubebuilder:validation:Optional
	Config *string `json:"config,omitempty" tf:"config,omitempty"`

	// +kubebuilder:validation:Optional
	Disabled *bool `json:"disabled,omitempty" tf:"disabled,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`
}

type ServerlessKubernetesObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type ServerlessKubernetesParameters struct {

	// +kubebuilder:validation:Optional
	Addons []ServerlessKubernetesAddonsParameters `json:"addons,omitempty" tf:"addons,omitempty"`

	// +kubebuilder:validation:Optional
	ClientCert *string `json:"clientCert,omitempty" tf:"client_cert,omitempty"`

	// +kubebuilder:validation:Optional
	ClientKey *string `json:"clientKey,omitempty" tf:"client_key,omitempty"`

	// +kubebuilder:validation:Optional
	ClusterCACert *string `json:"clusterCaCert,omitempty" tf:"cluster_ca_cert,omitempty"`

	// +kubebuilder:validation:Optional
	DeletionProtection *bool `json:"deletionProtection,omitempty" tf:"deletion_protection,omitempty"`

	// +kubebuilder:validation:Optional
	EndpointPublicAccessEnabled *bool `json:"endpointPublicAccessEnabled,omitempty" tf:"endpoint_public_access_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	ForceUpdate *bool `json:"forceUpdate,omitempty" tf:"force_update,omitempty"`

	// +kubebuilder:validation:Optional
	KubeConfig *string `json:"kubeConfig,omitempty" tf:"kube_config,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancerSpec *string `json:"loadBalancerSpec,omitempty" tf:"load_balancer_spec,omitempty"`

	// +kubebuilder:validation:Optional
	LoggingType *string `json:"loggingType,omitempty" tf:"logging_type,omitempty"`

	// +kubebuilder:validation:Optional
	NewNATGateway *bool `json:"newNatGateway,omitempty" tf:"new_nat_gateway,omitempty"`

	// +kubebuilder:validation:Optional
	PrivateZone *bool `json:"privateZone,omitempty" tf:"private_zone,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupID *string `json:"resourceGroupId,omitempty" tf:"resource_group_id,omitempty"`

	// +kubebuilder:validation:Optional
	RetainResources []*string `json:"retainResources,omitempty" tf:"retain_resources,omitempty"`

	// +kubebuilder:validation:Optional
	SecurityGroupID *string `json:"securityGroupId,omitempty" tf:"security_group_id,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceCidr *string `json:"serviceCidr,omitempty" tf:"service_cidr,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceDiscoveryTypes []*string `json:"serviceDiscoveryTypes,omitempty" tf:"service_discovery_types,omitempty"`

	// +kubebuilder:validation:Optional
	SlsProjectName *string `json:"slsProjectName,omitempty" tf:"sls_project_name,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	TimeZone *string `json:"timeZone,omitempty" tf:"time_zone,omitempty"`

	// +kubebuilder:validation:Required
	VPCID *string `json:"vpcId" tf:"vpc_id,omitempty"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`

	// +kubebuilder:validation:Optional
	VswitchID *string `json:"vswitchId,omitempty" tf:"vswitch_id,omitempty"`

	// +kubebuilder:validation:Optional
	VswitchIds []*string `json:"vswitchIds,omitempty" tf:"vswitch_ids,omitempty"`

	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

// ServerlessKubernetesSpec defines the desired state of ServerlessKubernetes
type ServerlessKubernetesSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ServerlessKubernetesParameters `json:"forProvider"`
}

// ServerlessKubernetesStatus defines the observed state of ServerlessKubernetes.
type ServerlessKubernetesStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ServerlessKubernetesObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ServerlessKubernetes is the Schema for the ServerlessKubernetess API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type ServerlessKubernetes struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ServerlessKubernetesSpec   `json:"spec"`
	Status            ServerlessKubernetesStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ServerlessKubernetesList contains a list of ServerlessKubernetess
type ServerlessKubernetesList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ServerlessKubernetes `json:"items"`
}

// Repository type metadata.
var (
	ServerlessKubernetes_Kind             = "ServerlessKubernetes"
	ServerlessKubernetes_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ServerlessKubernetes_Kind}.String()
	ServerlessKubernetes_KindAPIVersion   = ServerlessKubernetes_Kind + "." + CRDGroupVersion.String()
	ServerlessKubernetes_GroupVersionKind = CRDGroupVersion.WithKind(ServerlessKubernetes_Kind)
)

func init() {
	SchemeBuilder.Register(&ServerlessKubernetes{}, &ServerlessKubernetesList{})
}
