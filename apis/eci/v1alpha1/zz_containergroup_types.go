/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ConfigFileVolumeConfigFileToPathsObservation struct {
}

type ConfigFileVolumeConfigFileToPathsParameters struct {

	// +kubebuilder:validation:Optional
	Content *string `json:"content,omitempty" tf:"content,omitempty"`

	// +kubebuilder:validation:Optional
	Path *string `json:"path,omitempty" tf:"path,omitempty"`
}

type ContainerGroupObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type ContainerGroupParameters struct {

	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +kubebuilder:validation:Required
	ContainerGroupName *string `json:"containerGroupName" tf:"container_group_name,omitempty"`

	// +kubebuilder:validation:Required
	Containers []ContainersParameters `json:"containers" tf:"containers,omitempty"`

	// +kubebuilder:validation:Optional
	DNSConfig []DNSConfigParameters `json:"dnsConfig,omitempty" tf:"dns_config,omitempty"`

	// +kubebuilder:validation:Optional
	EciSecurityContext []EciSecurityContextParameters `json:"eciSecurityContext,omitempty" tf:"eci_security_context,omitempty"`

	// +kubebuilder:validation:Optional
	HostAliases []HostAliasesParameters `json:"hostAliases,omitempty" tf:"host_aliases,omitempty"`

	// +kubebuilder:validation:Optional
	ImageRegistryCredential []ImageRegistryCredentialParameters `json:"imageRegistryCredential,omitempty" tf:"image_registry_credential,omitempty"`

	// +kubebuilder:validation:Optional
	InitContainers []InitContainersParameters `json:"initContainers,omitempty" tf:"init_containers,omitempty"`

	// +kubebuilder:validation:Optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`

	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// +kubebuilder:validation:Optional
	RAMRoleName *string `json:"ramRoleName,omitempty" tf:"ram_role_name,omitempty"`

	// +kubebuilder:validation:Optional
	ResourceGroupID *string `json:"resourceGroupId,omitempty" tf:"resource_group_id,omitempty"`

	// +kubebuilder:validation:Optional
	RestartPolicy *string `json:"restartPolicy,omitempty" tf:"restart_policy,omitempty"`

	// +kubebuilder:validation:Required
	SecurityGroupID *string `json:"securityGroupId" tf:"security_group_id,omitempty"`

	// +kubebuilder:validation:Optional
	Tags map[string]*string `json:"tags,omitempty" tf:"tags,omitempty"`

	// +kubebuilder:validation:Optional
	Volumes []VolumesParameters `json:"volumes,omitempty" tf:"volumes,omitempty"`

	// +kubebuilder:validation:Required
	VswitchID *string `json:"vswitchId" tf:"vswitch_id,omitempty"`

	// +kubebuilder:validation:Optional
	ZoneID *string `json:"zoneId,omitempty" tf:"zone_id,omitempty"`
}

type ContainersObservation struct {
	Ready *bool `json:"ready,omitempty" tf:"ready,omitempty"`

	RestartCount *float64 `json:"restartCount,omitempty" tf:"restart_count,omitempty"`
}

type ContainersParameters struct {

	// +kubebuilder:validation:Optional
	Args []*string `json:"args,omitempty" tf:"args,omitempty"`

	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +kubebuilder:validation:Optional
	Commands []*string `json:"commands,omitempty" tf:"commands,omitempty"`

	// +kubebuilder:validation:Optional
	EnvironmentVars []EnvironmentVarsParameters `json:"environmentVars,omitempty" tf:"environment_vars,omitempty"`

	// +kubebuilder:validation:Optional
	Gpu *float64 `json:"gpu,omitempty" tf:"gpu,omitempty"`

	// +kubebuilder:validation:Required
	Image *string `json:"image" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" tf:"image_pull_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Ports []PortsParameters `json:"ports,omitempty" tf:"ports,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeMounts []VolumeMountsParameters `json:"volumeMounts,omitempty" tf:"volume_mounts,omitempty"`

	// +kubebuilder:validation:Optional
	WorkingDir *string `json:"workingDir,omitempty" tf:"working_dir,omitempty"`
}

type DNSConfigObservation struct {
}

type DNSConfigParameters struct {

	// +kubebuilder:validation:Optional
	NameServers []*string `json:"nameServers,omitempty" tf:"name_servers,omitempty"`

	// +kubebuilder:validation:Optional
	Options []OptionsParameters `json:"options,omitempty" tf:"options,omitempty"`

	// +kubebuilder:validation:Optional
	Searches []*string `json:"searches,omitempty" tf:"searches,omitempty"`
}

type EciSecurityContextObservation struct {
}

type EciSecurityContextParameters struct {

	// +kubebuilder:validation:Optional
	Sysctls []SysctlsParameters `json:"sysctls,omitempty" tf:"sysctls,omitempty"`
}

type EnvironmentVarsObservation struct {
}

type EnvironmentVarsParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type HostAliasesObservation struct {
}

type HostAliasesParameters struct {

	// +kubebuilder:validation:Optional
	Hostnames []*string `json:"hostnames,omitempty" tf:"hostnames,omitempty"`

	// +kubebuilder:validation:Optional
	IP *string `json:"ip,omitempty" tf:"ip,omitempty"`
}

type ImageRegistryCredentialObservation struct {
}

type ImageRegistryCredentialParameters struct {

	// +kubebuilder:validation:Required
	Password *string `json:"password" tf:"password,omitempty"`

	// +kubebuilder:validation:Required
	Server *string `json:"server" tf:"server,omitempty"`

	// +kubebuilder:validation:Required
	UserName *string `json:"userName" tf:"user_name,omitempty"`
}

type InitContainersEnvironmentVarsObservation struct {
}

type InitContainersEnvironmentVarsParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type InitContainersObservation struct {
	Ready *bool `json:"ready,omitempty" tf:"ready,omitempty"`

	RestartCount *float64 `json:"restartCount,omitempty" tf:"restart_count,omitempty"`
}

type InitContainersParameters struct {

	// +kubebuilder:validation:Optional
	Args []*string `json:"args,omitempty" tf:"args,omitempty"`

	// +kubebuilder:validation:Optional
	CPU *float64 `json:"cpu,omitempty" tf:"cpu,omitempty"`

	// +kubebuilder:validation:Optional
	Commands []*string `json:"commands,omitempty" tf:"commands,omitempty"`

	// +kubebuilder:validation:Optional
	EnvironmentVars []InitContainersEnvironmentVarsParameters `json:"environmentVars,omitempty" tf:"environment_vars,omitempty"`

	// +kubebuilder:validation:Optional
	Gpu *float64 `json:"gpu,omitempty" tf:"gpu,omitempty"`

	// +kubebuilder:validation:Optional
	Image *string `json:"image,omitempty" tf:"image,omitempty"`

	// +kubebuilder:validation:Optional
	ImagePullPolicy *string `json:"imagePullPolicy,omitempty" tf:"image_pull_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Memory *float64 `json:"memory,omitempty" tf:"memory,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Ports []InitContainersPortsParameters `json:"ports,omitempty" tf:"ports,omitempty"`

	// +kubebuilder:validation:Optional
	VolumeMounts []InitContainersVolumeMountsParameters `json:"volumeMounts,omitempty" tf:"volume_mounts,omitempty"`

	// +kubebuilder:validation:Optional
	WorkingDir *string `json:"workingDir,omitempty" tf:"working_dir,omitempty"`
}

type InitContainersPortsObservation struct {
}

type InitContainersPortsParameters struct {

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

type InitContainersVolumeMountsObservation struct {
}

type InitContainersVolumeMountsParameters struct {

	// +kubebuilder:validation:Optional
	MountPath *string `json:"mountPath,omitempty" tf:"mount_path,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type OptionsObservation struct {
}

type OptionsParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type PortsObservation struct {
}

type PortsParameters struct {

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`
}

type SysctlsObservation struct {
}

type SysctlsParameters struct {

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Value *string `json:"value,omitempty" tf:"value,omitempty"`
}

type VolumeMountsObservation struct {
}

type VolumeMountsParameters struct {

	// +kubebuilder:validation:Optional
	MountPath *string `json:"mountPath,omitempty" tf:"mount_path,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ReadOnly *bool `json:"readOnly,omitempty" tf:"read_only,omitempty"`
}

type VolumesObservation struct {
}

type VolumesParameters struct {

	// +kubebuilder:validation:Optional
	ConfigFileVolumeConfigFileToPaths []ConfigFileVolumeConfigFileToPathsParameters `json:"configFileVolumeConfigFileToPaths,omitempty" tf:"config_file_volume_config_file_to_paths,omitempty"`

	// +kubebuilder:validation:Optional
	DiskVolumeDiskID *string `json:"diskVolumeDiskId,omitempty" tf:"disk_volume_disk_id,omitempty"`

	// +kubebuilder:validation:Optional
	DiskVolumeFsType *string `json:"diskVolumeFsType,omitempty" tf:"disk_volume_fs_type,omitempty"`

	// +kubebuilder:validation:Optional
	FlexVolumeDriver *string `json:"flexVolumeDriver,omitempty" tf:"flex_volume_driver,omitempty"`

	// +kubebuilder:validation:Optional
	FlexVolumeFsType *string `json:"flexVolumeFsType,omitempty" tf:"flex_volume_fs_type,omitempty"`

	// +kubebuilder:validation:Optional
	FlexVolumeOptions *string `json:"flexVolumeOptions,omitempty" tf:"flex_volume_options,omitempty"`

	// +kubebuilder:validation:Optional
	NFSVolumePath *string `json:"nfsVolumePath,omitempty" tf:"nfs_volume_path,omitempty"`

	// +kubebuilder:validation:Optional
	NFSVolumeReadOnly *bool `json:"nfsVolumeReadOnly,omitempty" tf:"nfs_volume_read_only,omitempty"`

	// +kubebuilder:validation:Optional
	NFSVolumeServer *string `json:"nfsVolumeServer,omitempty" tf:"nfs_volume_server,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

// ContainerGroupSpec defines the desired state of ContainerGroup
type ContainerGroupSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     ContainerGroupParameters `json:"forProvider"`
}

// ContainerGroupStatus defines the observed state of ContainerGroup.
type ContainerGroupStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        ContainerGroupObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// ContainerGroup is the Schema for the ContainerGroups API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type ContainerGroup struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ContainerGroupSpec   `json:"spec"`
	Status            ContainerGroupStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// ContainerGroupList contains a list of ContainerGroups
type ContainerGroupList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ContainerGroup `json:"items"`
}

// Repository type metadata.
var (
	ContainerGroup_Kind             = "ContainerGroup"
	ContainerGroup_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: ContainerGroup_Kind}.String()
	ContainerGroup_KindAPIVersion   = ContainerGroup_Kind + "." + CRDGroupVersion.String()
	ContainerGroup_GroupVersionKind = CRDGroupVersion.WithKind(ContainerGroup_Kind)
)

func init() {
	SchemeBuilder.Register(&ContainerGroup{}, &ContainerGroupList{})
}
