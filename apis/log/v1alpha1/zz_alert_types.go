/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AlertObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type AlertParameters struct {

	// +kubebuilder:validation:Optional
	AlertDescription *string `json:"alertDescription,omitempty" tf:"alert_description,omitempty"`

	// +kubebuilder:validation:Required
	AlertDisplayname *string `json:"alertDisplayname" tf:"alert_displayname,omitempty"`

	// +kubebuilder:validation:Required
	AlertName *string `json:"alertName" tf:"alert_name,omitempty"`

	// +kubebuilder:validation:Required
	Condition *string `json:"condition" tf:"condition,omitempty"`

	// +kubebuilder:validation:Required
	Dashboard *string `json:"dashboard" tf:"dashboard,omitempty"`

	// +kubebuilder:validation:Optional
	MuteUntil *float64 `json:"muteUntil,omitempty" tf:"mute_until,omitempty"`

	// +kubebuilder:validation:Required
	NotificationList []NotificationListParameters `json:"notificationList" tf:"notification_list,omitempty"`

	// +kubebuilder:validation:Optional
	NotifyThreshold *float64 `json:"notifyThreshold,omitempty" tf:"notify_threshold,omitempty"`

	// +kubebuilder:validation:Required
	ProjectName *string `json:"projectName" tf:"project_name,omitempty"`

	// +kubebuilder:validation:Required
	QueryList []QueryListParameters `json:"queryList" tf:"query_list,omitempty"`

	// +kubebuilder:validation:Optional
	ScheduleInterval *string `json:"scheduleInterval,omitempty" tf:"schedule_interval,omitempty"`

	// +kubebuilder:validation:Optional
	ScheduleType *string `json:"scheduleType,omitempty" tf:"schedule_type,omitempty"`

	// +kubebuilder:validation:Optional
	Throttling *string `json:"throttling,omitempty" tf:"throttling,omitempty"`
}

type NotificationListObservation struct {
}

type NotificationListParameters struct {

	// +kubebuilder:validation:Required
	Content *string `json:"content" tf:"content,omitempty"`

	// +kubebuilder:validation:Optional
	EmailList []*string `json:"emailList,omitempty" tf:"email_list,omitempty"`

	// +kubebuilder:validation:Optional
	MobileList []*string `json:"mobileList,omitempty" tf:"mobile_list,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceURI *string `json:"serviceUri,omitempty" tf:"service_uri,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type QueryListObservation struct {
}

type QueryListParameters struct {

	// +kubebuilder:validation:Required
	ChartTitle *string `json:"chartTitle" tf:"chart_title,omitempty"`

	// +kubebuilder:validation:Required
	End *string `json:"end" tf:"end,omitempty"`

	// +kubebuilder:validation:Required
	Logstore *string `json:"logstore" tf:"logstore,omitempty"`

	// +kubebuilder:validation:Required
	Query *string `json:"query" tf:"query,omitempty"`

	// +kubebuilder:validation:Required
	Start *string `json:"start" tf:"start,omitempty"`

	// +kubebuilder:validation:Optional
	TimeSpanType *string `json:"timeSpanType,omitempty" tf:"time_span_type,omitempty"`
}

// AlertSpec defines the desired state of Alert
type AlertSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     AlertParameters `json:"forProvider"`
}

// AlertStatus defines the observed state of Alert.
type AlertStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        AlertObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// Alert is the Schema for the Alerts API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type Alert struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AlertSpec   `json:"spec"`
	Status            AlertStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// AlertList contains a list of Alerts
type AlertList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Alert `json:"items"`
}

// Repository type metadata.
var (
	Alert_Kind             = "Alert"
	Alert_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: Alert_Kind}.String()
	Alert_KindAPIVersion   = Alert_Kind + "." + CRDGroupVersion.String()
	Alert_GroupVersionKind = CRDGroupVersion.WithKind(Alert_Kind)
)

func init() {
	SchemeBuilder.Register(&Alert{}, &AlertList{})
}
