/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AccessLogObservation struct {
}

type AccessLogParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type AuditObservation struct {
}

type AuditParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`
}

type KialiObservation struct {
}

type KialiParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
}

type LoadBalancerObservation struct {
	APIServerLoadbalancerID *string `json:"apiServerLoadbalancerId,omitempty" tf:"api_server_loadbalancer_id,omitempty"`

	PilotPublicLoadbalancerID *string `json:"pilotPublicLoadbalancerId,omitempty" tf:"pilot_public_loadbalancer_id,omitempty"`
}

type LoadBalancerParameters struct {

	// +kubebuilder:validation:Optional
	APIServerPublicEIP *bool `json:"apiServerPublicEip,omitempty" tf:"api_server_public_eip,omitempty"`

	// +kubebuilder:validation:Optional
	PilotPublicEIP *bool `json:"pilotPublicEip,omitempty" tf:"pilot_public_eip,omitempty"`
}

type MeshConfigObservation struct {
}

type MeshConfigParameters struct {

	// +kubebuilder:validation:Optional
	AccessLog []AccessLogParameters `json:"accessLog,omitempty" tf:"access_log,omitempty"`

	// +kubebuilder:validation:Optional
	Audit []AuditParameters `json:"audit,omitempty" tf:"audit,omitempty"`

	// +kubebuilder:validation:Optional
	CustomizedZipkin *bool `json:"customizedZipkin,omitempty" tf:"customized_zipkin,omitempty"`

	// +kubebuilder:validation:Optional
	EnableLocalityLB *bool `json:"enableLocalityLb,omitempty" tf:"enable_locality_lb,omitempty"`

	// +kubebuilder:validation:Optional
	Kiali []KialiParameters `json:"kiali,omitempty" tf:"kiali,omitempty"`

	// +kubebuilder:validation:Optional
	Opa []OpaParameters `json:"opa,omitempty" tf:"opa,omitempty"`

	// +kubebuilder:validation:Optional
	OutboundTrafficPolicy *string `json:"outboundTrafficPolicy,omitempty" tf:"outbound_traffic_policy,omitempty"`

	// +kubebuilder:validation:Optional
	Pilot []PilotParameters `json:"pilot,omitempty" tf:"pilot,omitempty"`

	// +kubebuilder:validation:Optional
	Proxy []ProxyParameters `json:"proxy,omitempty" tf:"proxy,omitempty"`

	// +kubebuilder:validation:Optional
	SidecarInjector []SidecarInjectorParameters `json:"sidecarInjector,omitempty" tf:"sidecar_injector,omitempty"`

	// +kubebuilder:validation:Optional
	Telemetry *bool `json:"telemetry,omitempty" tf:"telemetry,omitempty"`

	// +kubebuilder:validation:Optional
	Tracing *bool `json:"tracing,omitempty" tf:"tracing,omitempty"`
}

type MeshServiceMeshObservation struct {
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Status *string `json:"status,omitempty" tf:"status,omitempty"`
}

type MeshServiceMeshParameters struct {

	// +kubebuilder:validation:Optional
	Edition *string `json:"edition,omitempty" tf:"edition,omitempty"`

	// +kubebuilder:validation:Optional
	Force *bool `json:"force,omitempty" tf:"force,omitempty"`

	// +kubebuilder:validation:Optional
	LoadBalancer []LoadBalancerParameters `json:"loadBalancer,omitempty" tf:"load_balancer,omitempty"`

	// +kubebuilder:validation:Optional
	MeshConfig []MeshConfigParameters `json:"meshConfig,omitempty" tf:"mesh_config,omitempty"`

	// +kubebuilder:validation:Required
	Network []NetworkParameters `json:"network" tf:"network,omitempty"`

	// +kubebuilder:validation:Optional
	ServiceMeshName *string `json:"serviceMeshName,omitempty" tf:"service_mesh_name,omitempty"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type NetworkObservation struct {
}

type NetworkParameters struct {

	// +kubebuilder:validation:Required
	VPCID *string `json:"vpcId" tf:"vpc_id,omitempty"`

	// +kubebuilder:validation:Required
	VswitcheList []*string `json:"vswitcheList" tf:"vswitche_list,omitempty"`
}

type OpaObservation struct {
}

type OpaParameters struct {

	// +kubebuilder:validation:Optional
	Enabled *bool `json:"enabled,omitempty" tf:"enabled,omitempty"`

	// +kubebuilder:validation:Optional
	LimitCPU *string `json:"limitCpu,omitempty" tf:"limit_cpu,omitempty"`

	// +kubebuilder:validation:Optional
	LimitMemory *string `json:"limitMemory,omitempty" tf:"limit_memory,omitempty"`

	// +kubebuilder:validation:Optional
	LogLevel *string `json:"logLevel,omitempty" tf:"log_level,omitempty"`

	// +kubebuilder:validation:Optional
	RequestCPU *string `json:"requestCpu,omitempty" tf:"request_cpu,omitempty"`

	// +kubebuilder:validation:Optional
	RequestMemory *string `json:"requestMemory,omitempty" tf:"request_memory,omitempty"`
}

type PilotObservation struct {
}

type PilotParameters struct {

	// +kubebuilder:validation:Optional
	Http10Enabled *bool `json:"http10Enabled,omitempty" tf:"http10_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	TraceSampling *float64 `json:"traceSampling,omitempty" tf:"trace_sampling,omitempty"`
}

type ProxyObservation struct {
}

type ProxyParameters struct {

	// +kubebuilder:validation:Optional
	LimitCPU *string `json:"limitCpu,omitempty" tf:"limit_cpu,omitempty"`

	// +kubebuilder:validation:Optional
	LimitMemory *string `json:"limitMemory,omitempty" tf:"limit_memory,omitempty"`

	// +kubebuilder:validation:Optional
	RequestCPU *string `json:"requestCpu,omitempty" tf:"request_cpu,omitempty"`

	// +kubebuilder:validation:Optional
	RequestMemory *string `json:"requestMemory,omitempty" tf:"request_memory,omitempty"`
}

type SidecarInjectorObservation struct {
}

type SidecarInjectorParameters struct {

	// +kubebuilder:validation:Optional
	AutoInjectionPolicyEnabled *bool `json:"autoInjectionPolicyEnabled,omitempty" tf:"auto_injection_policy_enabled,omitempty"`

	// +kubebuilder:validation:Optional
	EnableNamespacesByDefault *bool `json:"enableNamespacesByDefault,omitempty" tf:"enable_namespaces_by_default,omitempty"`

	// +kubebuilder:validation:Optional
	LimitCPU *string `json:"limitCpu,omitempty" tf:"limit_cpu,omitempty"`

	// +kubebuilder:validation:Optional
	LimitMemory *string `json:"limitMemory,omitempty" tf:"limit_memory,omitempty"`

	// +kubebuilder:validation:Optional
	RequestCPU *string `json:"requestCpu,omitempty" tf:"request_cpu,omitempty"`

	// +kubebuilder:validation:Optional
	RequestMemory *string `json:"requestMemory,omitempty" tf:"request_memory,omitempty"`
}

// MeshServiceMeshSpec defines the desired state of MeshServiceMesh
type MeshServiceMeshSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     MeshServiceMeshParameters `json:"forProvider"`
}

// MeshServiceMeshStatus defines the observed state of MeshServiceMesh.
type MeshServiceMeshStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        MeshServiceMeshObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MeshServiceMesh is the Schema for the MeshServiceMeshs API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type MeshServiceMesh struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MeshServiceMeshSpec   `json:"spec"`
	Status            MeshServiceMeshStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MeshServiceMeshList contains a list of MeshServiceMeshs
type MeshServiceMeshList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MeshServiceMesh `json:"items"`
}

// Repository type metadata.
var (
	MeshServiceMesh_Kind             = "MeshServiceMesh"
	MeshServiceMesh_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: MeshServiceMesh_Kind}.String()
	MeshServiceMesh_KindAPIVersion   = MeshServiceMesh_Kind + "." + CRDGroupVersion.String()
	MeshServiceMesh_GroupVersionKind = CRDGroupVersion.WithKind(MeshServiceMesh_Kind)
)

func init() {
	SchemeBuilder.Register(&MeshServiceMesh{}, &MeshServiceMeshList{})
}
