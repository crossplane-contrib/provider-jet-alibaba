/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type VPNServerObservation struct {
	Connections *float64 `json:"connections,omitempty" tf:"connections,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	InternetIP *string `json:"internetIp,omitempty" tf:"internet_ip,omitempty"`

	MaxConnections *float64 `json:"maxConnections,omitempty" tf:"max_connections,omitempty"`
}

type VPNServerParameters struct {

	// +kubebuilder:validation:Optional
	Cipher *string `json:"cipher,omitempty" tf:"cipher,omitempty"`

	// +kubebuilder:validation:Required
	ClientIPPool *string `json:"clientIpPool" tf:"client_ip_pool,omitempty"`

	// +kubebuilder:validation:Optional
	Compress *bool `json:"compress,omitempty" tf:"compress,omitempty"`

	// +kubebuilder:validation:Required
	LocalSubnet *string `json:"localSubnet" tf:"local_subnet,omitempty"`

	// +kubebuilder:validation:Optional
	Port *float64 `json:"port,omitempty" tf:"port,omitempty"`

	// +kubebuilder:validation:Optional
	Protocol *string `json:"protocol,omitempty" tf:"protocol,omitempty"`

	// +kubebuilder:validation:Required
	VPNGatewayID *string `json:"vpnGatewayId" tf:"vpn_gateway_id,omitempty"`
}

// VPNServerSpec defines the desired state of VPNServer
type VPNServerSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VPNServerParameters `json:"forProvider"`
}

// VPNServerStatus defines the observed state of VPNServer.
type VPNServerStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VPNServerObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VPNServer is the Schema for the VPNServers API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,alicloudjet}
type VPNServer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VPNServerSpec   `json:"spec"`
	Status            VPNServerStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VPNServerList contains a list of VPNServers
type VPNServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VPNServer `json:"items"`
}

// Repository type metadata.
var (
	VPNServer_Kind             = "VPNServer"
	VPNServer_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: VPNServer_Kind}.String()
	VPNServer_KindAPIVersion   = VPNServer_Kind + "." + CRDGroupVersion.String()
	VPNServer_GroupVersionKind = CRDGroupVersion.WithKind(VPNServer_Kind)
)

func init() {
	SchemeBuilder.Register(&VPNServer{}, &VPNServerList{})
}
